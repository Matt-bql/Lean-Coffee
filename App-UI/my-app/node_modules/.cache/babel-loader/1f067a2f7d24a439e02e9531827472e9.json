{"ast":null,"code":"export default function Timer() {\n  var interval = 200; // ms\n\n  var expected = Date.now() + interval;\n  var drift_history = [];\n  var drift_history_samples = 10;\n  var drift_correction = 0;\n\n  function calc_drift(arr) {\n    // Calculate drift correction.\n\n    /*\n    In this example I've used a simple median.\n    You can use other methods, but it's important not to use an average. \n    If the user switches tabs and back, an average would put far too much\n    weight on the outlier.\n    */\n    var values = arr.concat(); // copy array so it isn't mutated\n\n    values.sort(function (a, b) {\n      return a - b;\n    });\n    if (values.length === 0) return 0;\n    var half = Math.floor(values.length / 2);\n    if (values.length % 2) return values[half];\n    var median = (values[half - 1] + values[half]) / 2.0;\n    return median;\n  }\n\n  setTimeout(step, interval);\n\n  function step() {\n    var dt = Date.now() - expected; // the drift (positive for overshooting)\n\n    if (dt > interval) {// something really bad happened. Maybe the browser (tab) was inactive?\n      // possibly special handling to avoid futile \"catch up\" run\n    } // do what is to be done\n    // don't update the history for exceptionally large values\n\n\n    if (dt <= interval) {\n      // sample drift amount to history after removing current correction\n      // (add to remove because the correction is applied by subtraction)\n      drift_history.push(dt + drift_correction); // predict new drift correction\n\n      drift_correction = calc_drift(drift_history); // cap and refresh samples\n\n      if (drift_history.length >= drift_history_samples) {\n        drift_history.shift();\n      }\n    }\n\n    expected += interval; // take into account drift with prediction\n\n    setTimeout(step, Math.max(0, interval - dt - drift_correction));\n  }\n}\n_c = Timer;\n\nvar _c;\n\n$RefreshReg$(_c, \"Timer\");","map":{"version":3,"sources":["/Users/lisab/Dev/Lean-Coffee/App-UI/my-app/src/components/Timer/Timer.js"],"names":["Timer","interval","expected","Date","now","drift_history","drift_history_samples","drift_correction","calc_drift","arr","values","concat","sort","a","b","length","half","Math","floor","median","setTimeout","step","dt","push","shift","max"],"mappings":"AAAA,eAAe,SAASA,KAAT,GAAiB;AAC9B,MAAIC,QAAQ,GAAG,GAAf,CAD8B,CACV;;AACpB,MAAIC,QAAQ,GAAGC,IAAI,CAACC,GAAL,KAAaH,QAA5B;AAEA,MAAII,aAAa,GAAG,EAApB;AACA,MAAIC,qBAAqB,GAAG,EAA5B;AACA,MAAIC,gBAAgB,GAAG,CAAvB;;AAEA,WAASC,UAAT,CAAoBC,GAApB,EAAyB;AACvB;;AAEA;AACJ;AACA;AACA;AACA;AACA;AAEI,QAAIC,MAAM,GAAGD,GAAG,CAACE,MAAJ,EAAb,CAVuB,CAUI;;AAE3BD,IAAAA,MAAM,CAACE,IAAP,CAAY,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAC1B,aAAOD,CAAC,GAAGC,CAAX;AACD,KAFD;AAGA,QAAIJ,MAAM,CAACK,MAAP,KAAkB,CAAtB,EAAyB,OAAO,CAAP;AACzB,QAAIC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWR,MAAM,CAACK,MAAP,GAAgB,CAA3B,CAAX;AACA,QAAIL,MAAM,CAACK,MAAP,GAAgB,CAApB,EAAuB,OAAOL,MAAM,CAACM,IAAD,CAAb;AACvB,QAAIG,MAAM,GAAG,CAACT,MAAM,CAACM,IAAI,GAAG,CAAR,CAAN,GAAmBN,MAAM,CAACM,IAAD,CAA1B,IAAoC,GAAjD;AAEA,WAAOG,MAAP;AACD;;AAEDC,EAAAA,UAAU,CAACC,IAAD,EAAOpB,QAAP,CAAV;;AACA,WAASoB,IAAT,GAAgB;AACd,QAAIC,EAAE,GAAGnB,IAAI,CAACC,GAAL,KAAaF,QAAtB,CADc,CACkB;;AAChC,QAAIoB,EAAE,GAAGrB,QAAT,EAAmB,CACjB;AACA;AACD,KALa,CAMd;AAEA;;;AACA,QAAIqB,EAAE,IAAIrB,QAAV,EAAoB;AAClB;AACA;AACAI,MAAAA,aAAa,CAACkB,IAAd,CAAmBD,EAAE,GAAGf,gBAAxB,EAHkB,CAKlB;;AACAA,MAAAA,gBAAgB,GAAGC,UAAU,CAACH,aAAD,CAA7B,CANkB,CAQlB;;AACA,UAAIA,aAAa,CAACU,MAAd,IAAwBT,qBAA5B,EAAmD;AACjDD,QAAAA,aAAa,CAACmB,KAAd;AACD;AACF;;AAEDtB,IAAAA,QAAQ,IAAID,QAAZ,CAvBc,CAwBd;;AACAmB,IAAAA,UAAU,CAACC,IAAD,EAAOJ,IAAI,CAACQ,GAAL,CAAS,CAAT,EAAYxB,QAAQ,GAAGqB,EAAX,GAAgBf,gBAA5B,CAAP,CAAV;AACD;AACF;KA3DuBP,K","sourcesContent":["export default function Timer() {\n  var interval = 200; // ms\n  var expected = Date.now() + interval;\n\n  var drift_history = [];\n  var drift_history_samples = 10;\n  var drift_correction = 0;\n\n  function calc_drift(arr) {\n    // Calculate drift correction.\n\n    /*\n  In this example I've used a simple median.\n  You can use other methods, but it's important not to use an average. \n  If the user switches tabs and back, an average would put far too much\n  weight on the outlier.\n  */\n\n    var values = arr.concat(); // copy array so it isn't mutated\n\n    values.sort(function (a, b) {\n      return a - b;\n    });\n    if (values.length === 0) return 0;\n    var half = Math.floor(values.length / 2);\n    if (values.length % 2) return values[half];\n    var median = (values[half - 1] + values[half]) / 2.0;\n\n    return median;\n  }\n\n  setTimeout(step, interval);\n  function step() {\n    var dt = Date.now() - expected; // the drift (positive for overshooting)\n    if (dt > interval) {\n      // something really bad happened. Maybe the browser (tab) was inactive?\n      // possibly special handling to avoid futile \"catch up\" run\n    }\n    // do what is to be done\n\n    // don't update the history for exceptionally large values\n    if (dt <= interval) {\n      // sample drift amount to history after removing current correction\n      // (add to remove because the correction is applied by subtraction)\n      drift_history.push(dt + drift_correction);\n\n      // predict new drift correction\n      drift_correction = calc_drift(drift_history);\n\n      // cap and refresh samples\n      if (drift_history.length >= drift_history_samples) {\n        drift_history.shift();\n      }\n    }\n\n    expected += interval;\n    // take into account drift with prediction\n    setTimeout(step, Math.max(0, interval - dt - drift_correction));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}